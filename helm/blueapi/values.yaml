# Default values for blueapi.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# -- How many replicated pods kubernetes should have running in the container.
replicaCount: 1

image:
  # -- Where to get the blueapi image from. Defaults to the blueapi image uploaded in the Github container registry (ghcr), which is updated on each release.
  repository: ghcr.io/diamondlightsource/blueapi
  # -- When to pull the image into the pods. Can be set to, 'IfNotPresent', 'Always' or 'Never'.
  pullPolicy: Always
  # -- Image tag, defaults to the chart appVersion.
  tag: ""

# -- Kubernetes secret(s) needed to access the repository hosting the image at image.repository.
imagePullSecrets: []
# -- Customise the application name used for all kubernetes objects instantiated by this chart. If null, the name becomes '<Release.Name>-<Chart.Name>' if the release and chart names are unique, or '<.Chart.Name>' if they are not. If this property is set, the name becomes '<.Release.Name>-<.Vallues.nameOverride>'.
nameOverride: ""
# -- Set the application name used for all kubernetes objects instantiated by this chart, overriding default configuations and those generated by setting '.Values.nameOverride'.
fullnameOverride: ""

serviceAccount:
  # If set to true, creates a serviceAccount on install.
  create: false
  # Annotations to add to the serviceAccount - only valid if serviceAccount.create is set to true.
  annotations: {}
  # The name to use for the serviceAccount - only valid if serviceAccount.create is set to true.
  # If not set, the app name configured by .Values.fullnameOverride or .Values.nameOverride is used (or the defaults given in their descriptions).
  name: ""

# -- Annotations to pass to the container pods.
podAnnotations: {}

# -- Define privilege/access settings for the container pods.
podSecurityContext:
  {}
  # fsGroup: 2000

# -- Define privilege/access settings for the container.
securityContext:
  {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  # -- What type of service to use to expose ports from the container. Recommended to use ClusterIP and set up an ingress.
  type: ClusterIP
  # -- Which port to expose to.
  port: 80

ingress:
  # -- Creates an ingress if set to true, which by default maps to the port of the service in .Values.service.
  create: false
#  host: foo.diamond.ac.uk  (assumes port = service.port)

# -- Resources to put into the container.
resources:
  {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# -- nodeSelector to put into the container.
nodeSelector: {}

# -- tolerations to put into the container.
tolerations: []

# -- affinity to put into the container.
affinity: {}

#existingSecret: see templates/secret.yaml

# -- indicates if the kubernetes objects created by this chart should run on the host network. This may be necessary for example to put values onto PVs, as their associated IOCs may only be accessible via the internal beamline network. Warning: some kubernetes configs may behave unexpectedly if this is set to true.
hostNetwork: false

listener:
  enabled: true
  resources: {}

scratch:
  # -- location of host machine directory to be mounted into the container as a volume. e.g. /usr/local/blueapi-software-scratch
  hostPath: ""
  # -- desired location of the mounted volume within the container
  containerPath: /blueapi-plugins/scratch

worker:
  api:
    # -- url at which to run blueapi rest server within the pod. Defaults to localhost; this gets exposed via a service and potentially ingress.
    host: 0.0.0.0 # Allow non-loopback traffic
    # -- port at which to expose blueapi rest server.
    port: 8000
  env:
    # -- blueapi will look at these python modules and import them differently based on if they contain devices or plans. See the corresponding modules for an example of how this should look like.
    sources:
      - kind: deviceFunctions
        module: blueapi.startup.example_devices
      - kind: planFunctions
        module: blueapi.startup.example_plans
      - kind: planFunctions
        module: dls_bluesky_core.plans
      - kind: planFunctions
        module: dls_bluesky_core.stubs
  stomp:
    auth:
      # -- username to authenticate to stomp within blueapi server.
      username: guest
      # -- passcode to authenticate to stomp within blueapi server. Strongly recommended to inject this as a sealed secret and *remove this line entirely* in your own implementations of this chart for security reasons.
      passcode: guest
    # -- name or url to use to connect to a running rabbitmq instance.
    host: rabbitmq
    # -- port to use to connect to a running rabbitmq instance.
    port: 61613

# Config for the worker goes here, will be mounted into a config file
